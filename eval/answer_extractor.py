import asyncio
import logging
import re
from ast import literal_eval

from openai.types.chat.parsed_chat_completion import ParsedChatCompletion
from pydantic import BaseModel

from dynamic_sketchpad.llm import LLM, create_message


def setup_logging():
    logging.basicConfig(
        level=logging.INFO,
        format="[%(name)s: %(asctime)s] {%(process)d} %(levelname)s - %(message)s",
    )
    return logging.getLogger(__name__)


logger = setup_logging()


async def extract_answer(question: str, response: str) -> int | None:
    answer = regex_extract_answer(response)
    if answer is None:
        logger.warning(
            f"Unable to extract answer using regex in response\n{response}\nUsing LLM for extraction."
        )
        extractor_llm = ExtractorLLM()
        answer = await extractor_llm.extract_answer(question, response)
        if answer is None:
            logger.warning(
                f"Unable to extract answer using LLM in response\n{response}"
            )
        else:
            logger.info(f"Extracted answer using LLM: {answer}")
    return answer


def regex_extract_answer(
    output: str,
    pattern: str = r"(?:[\*\_]*ANSWER[\*\_]*):\s*[\*\_]*(.+?)[\*\_]*[\s\.\!]*$",
) -> str | float | int | None:
    """
    Extracts the answer from LLM-generated output using a regex pattern.

    Args:
        output (str): The text generated by the LLM.
        pattern (str): Regex pattern to extract the answer.

    Returns:
        str | int | None: Extracted answer or None if not found.
    """
    re_match = re.search(pattern, output)
    if re_match is None:
        return None

    answer = re_match.group(1)

    try:
        return literal_eval(answer)
    except (ValueError, SyntaxError):
        return answer


# TODO: Is there a way to make this generic?
class ExtractedAnswer(BaseModel):
    answer: str | float | int | None


EXTRACTOR_INSTRUCTIONS = """
You are an Extractor LLM tasked with identifying and extracting the final answer(s) from a given explanation or response to a question. The final answer is typically a numerical value or a short textual conclusion explicitly stated in the response.
You will be given the question and the student's response.
If there is no final answer in the response, you should return None.

### Objective:
Identify the explicit final answer or answers in the text. Extract them as they appear without interpretation or modification.

### Key Guidelines:
1. **Identify the Answer:**
   - Look for the explicit numerical or textual conclusion labeled as the "answer."
   - The answer may appear at the end of the explanation, marked by phrases like "ANSWER:", "Final Answer:", or a concluding sentence.

2. **Extract as Is:**
   - Return the exact numerical or textual value provided as the final answer.

3. **Fallback Behavior:**
   - If no explicit final answer is found, return `None`

### Examples:

Example 1:
To solve the given max flow problem, we calculated the total maximum flow using the Edmonds-Karp algorithm. After summing up all the flows from the source node, we find the total maximum flow to be 6. ANSWER: 6
Extracted Answer: 6

Example 2:
The BFS algorithm helps us find augmenting paths, and we calculate the flow along each path. The total flow is derived by summing the flows along all augmenting paths.

Extracted Answer: None
**Reason:** No explicit final answer is stated in the explanation.
"""


class ExtractorLLM(LLM):
    def __init__(self, llm_str: str = "gpt-4o-mini"):
        super().__init__(llm_str=llm_str)

    async def parse_answer_completion(
        self, question: str, response: str
    ) -> ParsedChatCompletion[ExtractedAnswer]:
        instructions = EXTRACTOR_INSTRUCTIONS
        extractor_prompt = f"The question is {question} the response is {response}, extract the answer from the response."
        extractor_message = create_message("user", extractor_prompt)

        return await self.parse_completion(
            [extractor_message],
            response_format=ExtractedAnswer,
            instructions=instructions,
        )

    async def extract_answer(self, question: str, response: str) -> int | None:
        extraction_completion = await self.parse_answer_completion(question, response)
        answer = extraction_completion.choices[0].message.parsed.answer
        try:
            return literal_eval(answer)
        except (ValueError, SyntaxError):
            return answer


if __name__ == "__main__":
    expected_answer = 42
    llm_output = f"The problem is solved. ANSWER: **{expected_answer}**"
    answer = regex_extract_answer(llm_output)
    print("Extracted Answer:", answer)
    assert answer == expected_answer

    llm_output = "The solution is not provided in the response."
    answer = regex_extract_answer(llm_output)
    print("Extracted Answer:", answer)
    assert answer is None

    llm_output = "ANSWER: odd"
    answer = regex_extract_answer(llm_output)
    print("Extracted Answer:", answer)
    assert answer == "odd"

    extractor = ExtractorLLM()
    question = """
    "source_node": 0,
    "source_node_color": "red",
    "sink_node": 2,
    "sink_node_color": "blue",
    "adjacency_matrix": "[[0, 3, 3], [0, 0, 8], [0, 0, 0]]",

    What is the maximum flow from the red node to the blue node in the given graph?
"""
    response = """
    To solve this max flow problem, we'll make use of the **Edmonds-Karp algorithm**, which is an implementation of the Ford-Fulkerson method using BFS to find augmenting paths. Here's the step-by-step computation:

### Adjacency Matrix:
\[
\text{graph} = \begin{bmatrix}
0 & 9 & 6 & 8 & 4 \\
0 & 0 & 0 & 0 & 5 \\
0 & 3 & 0 & 0 & 9 \\
0 & 7 & 8 & 0 & 1 \\
0 & 0 & 0 & 0 & 0
\end{bmatrix}
\]

- **Source Node**: `0`
- **Sink Node**: `4`

### Algorithm Steps:
1. **Residual Graph**: Start with a residual capacity graph identical to the adjacency matrix.
2. **Augmenting Path Search**: Use BFS to find an augmenting path from the source to the sink. The bottleneck capacity (minimum edge capacity along the path) is computed.
3. **Update Residual Capacities**: Adjust the capacities along the augmenting path in the residual graph.
4. Repeat Steps 2-3 until no augmenting paths exist in the residual graph.
5. Compute the total maximum flow by summing the flows along edges leaving the source node.

---

### Step-by-Step Execution:

#### Initial Graph:
The adjacency matrix is given as follows:
\[
\text{graph} = \begin{bmatrix}
0 & 9 & 6 & 8 & 4 \\
0 & 0 & 0 & 0 & 5 \\
0 & 3 & 0 & 0 & 9 \\
0 & 7 & 8 & 0 & 1 \\
0 & 0 & 0 & 0 & 0
\end{bmatrix}
\]

#### Initialize:
- Maximum flow: `max_flow = 0`.
- Residual graph is initialized as the original graph.

---

#### Iteration 1 (Finding Augmenting Path):
- Perform BFS from node `0` (source) to node `4` (sink).
- Found path: `0 → 2 → 4`.
- Bottleneck capacity along this path: `min(6, 9) = 6`.

Update the residual graph:
- Residual capacity of edge `0 → 2` becomes `6 - 6 = 0`.
- Residual capacity of edge `2 → 4` becomes `9 - 6 = 3`.
- Add reverse edges with capacity equal to the flow along the path (`6`).

New residual graph:
\[
\text{residual_graph} = \begin{bmatrix}
0 & 9 & 0 & 8 & 4 \\
0 & 0 & 0 & 0 & 5 \\
6 & 3 & 0 & 0 & 3 \\
0 & 7 & 8 & 0 & 1 \\
0 & 0 & 6 & 0 & 0
\end{bmatrix}
\]

Update total flow: `max_flow += 6 → max_flow = 6`.

---

#### Iteration 2 (Finding Augmenting Path):
- Perform BFS from node `0` to node `4`.
- Found path: `0 → 3 → 4`.
- Bottleneck capacity along this path: `min(8, 1) = 1`.

Update the residual graph:
- Residual capacity of edge `0 → 3` becomes `8 - 1 = 7`.
- Residual capacity of edge `3 → 4` becomes `1 - 1 = 0`.
- Add reverse edges with capacity equal to the flow along the path (`1`).

New residual graph:
\[
\text{residual_graph} = \begin{bmatrix}
0 & 9 & 0 & 7 & 4 \\
0 & 0 & 0 & 0 & 5 \\
6 & 3 & 0 & 0 & 3 \\
0 & 7 & 8 & 0 & 0 \\
0 & 0 & 6 & 1 & 0
\end{bmatrix}
\]

Update total flow: `max_flow += 1 → max_flow = 7`.

---

#### Iteration 3 (Finding Augmenting Path):
- Perform BFS from node `0` to node `4`.
- Found path: `0 → 1 → 4`.
- Bottleneck capacity along this path: `min(9, 5) = 5`.

Update the residual graph:
- Residual capacity of edge `0 → 1` becomes `9 - 5 = 4`.
- Residual capacity of edge `1 → 4` becomes `5 - 5 = 0`.
- Add reverse edges with capacity equal to the flow along the path (`5`).

New residual graph:
\[
\text{residual_graph} = \begin{bmatrix}
0 & 4 & 0 & 7 & 4 \\
5 & 0 & 0 & 0 & 0 \\
6 & 3 & 0 & 0 & 3 \\
0 & 7 & 8 & 0 & 0 \\
0 & 5 & 6 & 1 & 0
\end{bmatrix}
\]

Update total flow: `max_flow += 5 → max_flow = 12`.

---

#### Iteration 4 (Finding Augmenting Path):
- Perform BFS from node `0` to node `4`.
- Found path: `0 → 0 → →!
    """

    expected_extraction = 12
    extracted_answer = asyncio.run(extractor.extract_answer(question, response))
    print("Extracted Answer:", extracted_answer)
    assert extracted_answer == expected_extraction
